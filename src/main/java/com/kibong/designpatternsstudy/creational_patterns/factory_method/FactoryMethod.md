# 팩토리 메소드(Factory Method) 패턴
구체적으로 어떤 인스턴스를 만들지는 서브클래스가 정한다.

## 사용 이유
클래스 자체가 점점 고도화 되어가다 보면 하나의 클래스(Concrete Class)로 감당하기에는 로직이 너무 복잡해진다.  
그러기에 인터페이스를 만들고 각각의 구체적인 팩토리 안에서 구체적인 인스턴스를 만들 수 있도록 해   
훨씬 더 유연한 확장에 용이한 구조로 코드를 만드는 패턴이다.

## 팩토리 메소드 패턴 적용 방법

### [간단하게 Factory Method로 구현하는 방법](ShipFactory.java)
하나의 인터페이스를 두고 구현체로 구현해 내면 된다.

간단하게 이렇게 구현해 내면 결국은 클라이언트 코드는 바뀌지 않느냐라는 생각이 들 수 있다.  

그래서 보통 의존성 주입을 해 인터페이스 기반으로 코딩하는 코드를 작성하고  
구체적인 클래스들은 의존성 주입방법을 써 클라인트 코드가 최대한 변경되지 않도록 할 수 있다.

### [인터페이스 적용하는 방법](injection%2FInjectionShipFactory.java)
변화의 변경은 필요에 따라 달라질 수 있다.
판드시 팩토리는 인터페이스로 정해야하고 추상클래스가 있어야하고 그런것은 아니다.

중요한 것은 구체적인 팩토리 안에서 구체적인 클래스를 만들어 낼 수 있다.
그게 중요한 것이다.

## 팩토리 메소드 패턴 장단점
### 장점
- 객체 지향 원칙 중에 OCP(Open Closed Principle) 이라는 원칙이 있다.  
- 확장에는 열려있고 변경에는 닫혀있어야 좀 더 유연하게 객체 지향적인 코드를 만들수 있다.  
-> 기존코드를 건드리지 않고 새롭게 확장 가능해야한다는 원칙  
- 인스턴스를 만들어내는 기존의 코드를 건드리지 않고 새롭게 확장 가능하도록 한다는 것이 장점이다.  
- 크리에이터와 프로덕트가 느슨한 결합(Loosely Coupled)이기에 확장에 열려있고 변경에 닫혀있는 코드를 작성할 수 있다.

### 단점
역활을 나누다 보면 클래스가 늘어나는 단점이 있다.

## 스프링에서 찾아보는 팩토리 패턴
- 기본으로 제공하는 Calendar가 팩토리 메서드 방식으로 제공하고 있다.
- 스프링에서 제공하는 빈 팩토리
  - ClassPathXmlApplicationContext 또는 AnnotationConfigApplicationContext이냐에 객체 생성이 달라짐

## 추가!
### Default 메소드
자바 8버전 부터 인터페이스에 기본적인 구현체를 만들 수 있어  
그 인터페이스를 상속 받은 또 다른 인터페이스에서도 해당 기능을 사용할 수 있겠금 되었다.  
-> 추상 클래스를 사용하지 않고도 추상 클래스에서 하던 일을 인터페이스에서 할 수 있게 됨(8버전 이후부터는 추상클래스 보다 default 메서드를 사용하는 것이 좋음)
